// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/common/kafka/consumer.go

// Package mock_kafkacommon is a generated GoMock package.
package mock_kafkacommon

import (
	reflect "reflect"
	time "time"

	kafka "github.com/confluentinc/confluent-kafka-go/kafka"
	gomock "github.com/golang/mock/gomock"
	kafkacommon "github.com/redhatinsights/edge-api/pkg/common/kafka"
)

// MockConsumer is a mock of Consumer interface.
type MockConsumer struct {
	ctrl     *gomock.Controller
	recorder *MockConsumerMockRecorder
}

// MockConsumerMockRecorder is the mock recorder for MockConsumer.
type MockConsumerMockRecorder struct {
	mock *MockConsumer
}

// NewMockConsumer creates a new mock instance.
func NewMockConsumer(ctrl *gomock.Controller) *MockConsumer {
	mock := &MockConsumer{ctrl: ctrl}
	mock.recorder = &MockConsumerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConsumer) EXPECT() *MockConsumerMockRecorder {
	return m.recorder
}

// Assign mocks base method.
func (m *MockConsumer) Assign(partitions []kafka.TopicPartition) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Assign", partitions)
	ret0, _ := ret[0].(error)
	return ret0
}

// Assign indicates an expected call of Assign.
func (mr *MockConsumerMockRecorder) Assign(partitions interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Assign", reflect.TypeOf((*MockConsumer)(nil).Assign), partitions)
}

// Assignment mocks base method.
func (m *MockConsumer) Assignment() ([]kafka.TopicPartition, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Assignment")
	ret0, _ := ret[0].([]kafka.TopicPartition)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Assignment indicates an expected call of Assignment.
func (mr *MockConsumerMockRecorder) Assignment() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Assignment", reflect.TypeOf((*MockConsumer)(nil).Assignment))
}

// AssignmentLost mocks base method.
func (m *MockConsumer) AssignmentLost() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AssignmentLost")
	ret0, _ := ret[0].(bool)
	return ret0
}

// AssignmentLost indicates an expected call of AssignmentLost.
func (mr *MockConsumerMockRecorder) AssignmentLost() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AssignmentLost", reflect.TypeOf((*MockConsumer)(nil).AssignmentLost))
}

// Close mocks base method.
func (m *MockConsumer) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockConsumerMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockConsumer)(nil).Close))
}

// Commit mocks base method.
func (m *MockConsumer) Commit() ([]kafka.TopicPartition, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].([]kafka.TopicPartition)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Commit indicates an expected call of Commit.
func (mr *MockConsumerMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockConsumer)(nil).Commit))
}

// CommitMessage mocks base method.
func (m_2 *MockConsumer) CommitMessage(m *kafka.Message) ([]kafka.TopicPartition, error) {
	m_2.ctrl.T.Helper()
	ret := m_2.ctrl.Call(m_2, "CommitMessage", m)
	ret0, _ := ret[0].([]kafka.TopicPartition)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CommitMessage indicates an expected call of CommitMessage.
func (mr *MockConsumerMockRecorder) CommitMessage(m interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommitMessage", reflect.TypeOf((*MockConsumer)(nil).CommitMessage), m)
}

// CommitOffsets mocks base method.
func (m *MockConsumer) CommitOffsets(offsets []kafka.TopicPartition) ([]kafka.TopicPartition, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CommitOffsets", offsets)
	ret0, _ := ret[0].([]kafka.TopicPartition)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CommitOffsets indicates an expected call of CommitOffsets.
func (mr *MockConsumerMockRecorder) CommitOffsets(offsets interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommitOffsets", reflect.TypeOf((*MockConsumer)(nil).CommitOffsets), offsets)
}

// Committed mocks base method.
func (m *MockConsumer) Committed(partitions []kafka.TopicPartition, timeoutMs int) ([]kafka.TopicPartition, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Committed", partitions, timeoutMs)
	ret0, _ := ret[0].([]kafka.TopicPartition)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Committed indicates an expected call of Committed.
func (mr *MockConsumerMockRecorder) Committed(partitions, timeoutMs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Committed", reflect.TypeOf((*MockConsumer)(nil).Committed), partitions, timeoutMs)
}

// Events mocks base method.
func (m *MockConsumer) Events() chan kafka.Event {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Events")
	ret0, _ := ret[0].(chan kafka.Event)
	return ret0
}

// Events indicates an expected call of Events.
func (mr *MockConsumerMockRecorder) Events() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Events", reflect.TypeOf((*MockConsumer)(nil).Events))
}

// GetConsumerGroupMetadata mocks base method.
func (m *MockConsumer) GetConsumerGroupMetadata() (*kafka.ConsumerGroupMetadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetConsumerGroupMetadata")
	ret0, _ := ret[0].(*kafka.ConsumerGroupMetadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetConsumerGroupMetadata indicates an expected call of GetConsumerGroupMetadata.
func (mr *MockConsumerMockRecorder) GetConsumerGroupMetadata() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetConsumerGroupMetadata", reflect.TypeOf((*MockConsumer)(nil).GetConsumerGroupMetadata))
}

// GetMetadata mocks base method.
func (m *MockConsumer) GetMetadata(topic *string, allTopics bool, timeoutMs int) (*kafka.Metadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMetadata", topic, allTopics, timeoutMs)
	ret0, _ := ret[0].(*kafka.Metadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMetadata indicates an expected call of GetMetadata.
func (mr *MockConsumerMockRecorder) GetMetadata(topic, allTopics, timeoutMs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMetadata", reflect.TypeOf((*MockConsumer)(nil).GetMetadata), topic, allTopics, timeoutMs)
}

// GetRebalanceProtocol mocks base method.
func (m *MockConsumer) GetRebalanceProtocol() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRebalanceProtocol")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetRebalanceProtocol indicates an expected call of GetRebalanceProtocol.
func (mr *MockConsumerMockRecorder) GetRebalanceProtocol() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRebalanceProtocol", reflect.TypeOf((*MockConsumer)(nil).GetRebalanceProtocol))
}

// GetWatermarkOffsets mocks base method.
func (m *MockConsumer) GetWatermarkOffsets(topic string, partition int32) (int64, int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWatermarkOffsets", topic, partition)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetWatermarkOffsets indicates an expected call of GetWatermarkOffsets.
func (mr *MockConsumerMockRecorder) GetWatermarkOffsets(topic, partition interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWatermarkOffsets", reflect.TypeOf((*MockConsumer)(nil).GetWatermarkOffsets), topic, partition)
}

// IncrementalAssign mocks base method.
func (m *MockConsumer) IncrementalAssign(partitions []kafka.TopicPartition) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IncrementalAssign", partitions)
	ret0, _ := ret[0].(error)
	return ret0
}

// IncrementalAssign indicates an expected call of IncrementalAssign.
func (mr *MockConsumerMockRecorder) IncrementalAssign(partitions interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IncrementalAssign", reflect.TypeOf((*MockConsumer)(nil).IncrementalAssign), partitions)
}

// IncrementalUnassign mocks base method.
func (m *MockConsumer) IncrementalUnassign(partitions []kafka.TopicPartition) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IncrementalUnassign", partitions)
	ret0, _ := ret[0].(error)
	return ret0
}

// IncrementalUnassign indicates an expected call of IncrementalUnassign.
func (mr *MockConsumerMockRecorder) IncrementalUnassign(partitions interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IncrementalUnassign", reflect.TypeOf((*MockConsumer)(nil).IncrementalUnassign), partitions)
}

// OffsetsForTimes mocks base method.
func (m *MockConsumer) OffsetsForTimes(times []kafka.TopicPartition, timeoutMs int) ([]kafka.TopicPartition, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OffsetsForTimes", times, timeoutMs)
	ret0, _ := ret[0].([]kafka.TopicPartition)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OffsetsForTimes indicates an expected call of OffsetsForTimes.
func (mr *MockConsumerMockRecorder) OffsetsForTimes(times, timeoutMs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OffsetsForTimes", reflect.TypeOf((*MockConsumer)(nil).OffsetsForTimes), times, timeoutMs)
}

// Pause mocks base method.
func (m *MockConsumer) Pause(partitions []kafka.TopicPartition) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pause", partitions)
	ret0, _ := ret[0].(error)
	return ret0
}

// Pause indicates an expected call of Pause.
func (mr *MockConsumerMockRecorder) Pause(partitions interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pause", reflect.TypeOf((*MockConsumer)(nil).Pause), partitions)
}

// Poll mocks base method.
func (m *MockConsumer) Poll(timeoutMs int) kafka.Event {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Poll", timeoutMs)
	ret0, _ := ret[0].(kafka.Event)
	return ret0
}

// Poll indicates an expected call of Poll.
func (mr *MockConsumerMockRecorder) Poll(timeoutMs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Poll", reflect.TypeOf((*MockConsumer)(nil).Poll), timeoutMs)
}

// Position mocks base method.
func (m *MockConsumer) Position(partitions []kafka.TopicPartition) ([]kafka.TopicPartition, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Position", partitions)
	ret0, _ := ret[0].([]kafka.TopicPartition)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Position indicates an expected call of Position.
func (mr *MockConsumerMockRecorder) Position(partitions interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Position", reflect.TypeOf((*MockConsumer)(nil).Position), partitions)
}

// QueryWatermarkOffsets mocks base method.
func (m *MockConsumer) QueryWatermarkOffsets(topic string, partition int32, timeoutMs int) (int64, int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryWatermarkOffsets", topic, partition, timeoutMs)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// QueryWatermarkOffsets indicates an expected call of QueryWatermarkOffsets.
func (mr *MockConsumerMockRecorder) QueryWatermarkOffsets(topic, partition, timeoutMs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryWatermarkOffsets", reflect.TypeOf((*MockConsumer)(nil).QueryWatermarkOffsets), topic, partition, timeoutMs)
}

// ReadMessage mocks base method.
func (m *MockConsumer) ReadMessage(timeout time.Duration) (*kafka.Message, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadMessage", timeout)
	ret0, _ := ret[0].(*kafka.Message)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadMessage indicates an expected call of ReadMessage.
func (mr *MockConsumerMockRecorder) ReadMessage(timeout interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadMessage", reflect.TypeOf((*MockConsumer)(nil).ReadMessage), timeout)
}

// Resume mocks base method.
func (m *MockConsumer) Resume(partitions []kafka.TopicPartition) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Resume", partitions)
	ret0, _ := ret[0].(error)
	return ret0
}

// Resume indicates an expected call of Resume.
func (mr *MockConsumerMockRecorder) Resume(partitions interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Resume", reflect.TypeOf((*MockConsumer)(nil).Resume), partitions)
}

// Seek mocks base method.
func (m *MockConsumer) Seek(partition kafka.TopicPartition, timeoutMs int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Seek", partition, timeoutMs)
	ret0, _ := ret[0].(error)
	return ret0
}

// Seek indicates an expected call of Seek.
func (mr *MockConsumerMockRecorder) Seek(partition, timeoutMs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Seek", reflect.TypeOf((*MockConsumer)(nil).Seek), partition, timeoutMs)
}

// SetOAuthBearerToken mocks base method.
func (m *MockConsumer) SetOAuthBearerToken(oauthBearerToken kafka.OAuthBearerToken) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetOAuthBearerToken", oauthBearerToken)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetOAuthBearerToken indicates an expected call of SetOAuthBearerToken.
func (mr *MockConsumerMockRecorder) SetOAuthBearerToken(oauthBearerToken interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetOAuthBearerToken", reflect.TypeOf((*MockConsumer)(nil).SetOAuthBearerToken), oauthBearerToken)
}

// SetOAuthBearerTokenFailure mocks base method.
func (m *MockConsumer) SetOAuthBearerTokenFailure(errstr string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetOAuthBearerTokenFailure", errstr)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetOAuthBearerTokenFailure indicates an expected call of SetOAuthBearerTokenFailure.
func (mr *MockConsumerMockRecorder) SetOAuthBearerTokenFailure(errstr interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetOAuthBearerTokenFailure", reflect.TypeOf((*MockConsumer)(nil).SetOAuthBearerTokenFailure), errstr)
}

// StoreMessage mocks base method.
func (m_2 *MockConsumer) StoreMessage(m *kafka.Message) ([]kafka.TopicPartition, error) {
	m_2.ctrl.T.Helper()
	ret := m_2.ctrl.Call(m_2, "StoreMessage", m)
	ret0, _ := ret[0].([]kafka.TopicPartition)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StoreMessage indicates an expected call of StoreMessage.
func (mr *MockConsumerMockRecorder) StoreMessage(m interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreMessage", reflect.TypeOf((*MockConsumer)(nil).StoreMessage), m)
}

// StoreOffsets mocks base method.
func (m *MockConsumer) StoreOffsets(offsets []kafka.TopicPartition) ([]kafka.TopicPartition, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreOffsets", offsets)
	ret0, _ := ret[0].([]kafka.TopicPartition)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StoreOffsets indicates an expected call of StoreOffsets.
func (mr *MockConsumerMockRecorder) StoreOffsets(offsets interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreOffsets", reflect.TypeOf((*MockConsumer)(nil).StoreOffsets), offsets)
}

// String mocks base method.
func (m *MockConsumer) String() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "String")
	ret0, _ := ret[0].(string)
	return ret0
}

// String indicates an expected call of String.
func (mr *MockConsumerMockRecorder) String() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "String", reflect.TypeOf((*MockConsumer)(nil).String))
}

// Subscribe mocks base method.
func (m *MockConsumer) Subscribe(topic string, rebalanceCb kafka.RebalanceCb) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Subscribe", topic, rebalanceCb)
	ret0, _ := ret[0].(error)
	return ret0
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockConsumerMockRecorder) Subscribe(topic, rebalanceCb interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockConsumer)(nil).Subscribe), topic, rebalanceCb)
}

// SubscribeTopics mocks base method.
func (m *MockConsumer) SubscribeTopics(topics []string, rebalanceCb kafka.RebalanceCb) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SubscribeTopics", topics, rebalanceCb)
	ret0, _ := ret[0].(error)
	return ret0
}

// SubscribeTopics indicates an expected call of SubscribeTopics.
func (mr *MockConsumerMockRecorder) SubscribeTopics(topics, rebalanceCb interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeTopics", reflect.TypeOf((*MockConsumer)(nil).SubscribeTopics), topics, rebalanceCb)
}

// Subscription mocks base method.
func (m *MockConsumer) Subscription() ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Subscription")
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscription indicates an expected call of Subscription.
func (mr *MockConsumerMockRecorder) Subscription() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscription", reflect.TypeOf((*MockConsumer)(nil).Subscription))
}

// Unassign mocks base method.
func (m *MockConsumer) Unassign() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unassign")
	ret0, _ := ret[0].(error)
	return ret0
}

// Unassign indicates an expected call of Unassign.
func (mr *MockConsumerMockRecorder) Unassign() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unassign", reflect.TypeOf((*MockConsumer)(nil).Unassign))
}

// Unsubscribe mocks base method.
func (m *MockConsumer) Unsubscribe() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unsubscribe")
	ret0, _ := ret[0].(error)
	return ret0
}

// Unsubscribe indicates an expected call of Unsubscribe.
func (mr *MockConsumerMockRecorder) Unsubscribe() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockConsumer)(nil).Unsubscribe))
}

// MockConsumerServiceInterface is a mock of ConsumerServiceInterface interface.
type MockConsumerServiceInterface struct {
	ctrl     *gomock.Controller
	recorder *MockConsumerServiceInterfaceMockRecorder
}

// MockConsumerServiceInterfaceMockRecorder is the mock recorder for MockConsumerServiceInterface.
type MockConsumerServiceInterfaceMockRecorder struct {
	mock *MockConsumerServiceInterface
}

// NewMockConsumerServiceInterface creates a new mock instance.
func NewMockConsumerServiceInterface(ctrl *gomock.Controller) *MockConsumerServiceInterface {
	mock := &MockConsumerServiceInterface{ctrl: ctrl}
	mock.recorder = &MockConsumerServiceInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConsumerServiceInterface) EXPECT() *MockConsumerServiceInterfaceMockRecorder {
	return m.recorder
}

// GetConsumer mocks base method.
func (m *MockConsumerServiceInterface) GetConsumer(groupID string) (kafkacommon.Consumer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetConsumer", groupID)
	ret0, _ := ret[0].(kafkacommon.Consumer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetConsumer indicates an expected call of GetConsumer.
func (mr *MockConsumerServiceInterfaceMockRecorder) GetConsumer(groupID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetConsumer", reflect.TypeOf((*MockConsumerServiceInterface)(nil).GetConsumer), groupID)
}

// GetInstanceConsumer mocks base method.
func (m *MockConsumerServiceInterface) GetInstanceConsumer(topics []string, groupID string) (kafkacommon.Consumer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetInstanceConsumer", topics, groupID)
	ret0, _ := ret[0].(kafkacommon.Consumer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetInstanceConsumer indicates an expected call of GetInstanceConsumer.
func (mr *MockConsumerServiceInterfaceMockRecorder) GetInstanceConsumer(topics, groupID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInstanceConsumer", reflect.TypeOf((*MockConsumerServiceInterface)(nil).GetInstanceConsumer), topics, groupID)
}
